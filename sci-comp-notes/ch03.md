Chapter 3: Number theory
========

[Return to all notes](index.html)

Number theory is in general the study of the integers and prime numbers are one of the most important pieces of this.  We will look at some of the computational study of number theory throughout this chapter, however, in short, this chapter shows a lot of interesting examples and how they are coded.  Later we will spend some time investigating the efficiency of the code here.

Prime Numbers
-----

Recall that a prime number is a positive integer whose only factors are 1 and itself.  Most languages have built-in versions of testing for primes, we will write some other versions.

Let's first start with a method that returns all of the factors of a given integer:

```
function allfactors(n::Integer)
    factors = [1]
    for i=2:n-1
        if mod(n,i)==0
            push!(factors,i)
        end
    end
    push!(factors,n)
end
```

This function starts with an array (list) consisting of only the number 1.  It then checks all numbers between 1 and n to see if each is a factor.  If it finds a factor, add it to the list with the `push` function.  


Exercise
-----

* Type in the function above and test it on various positive integers

* Use the function above to write a function `isPrime` that returns true or false depending on if the input is prime.  Hint: recall the definition of prime.  



Finding Primes
--------

We'll now try to find a prime number.  Many languages have a function called `nextPrime` that takes a number as an input and returns a prime number greater than that.  Here's a code fragment that may work:

```
function nextPrime(n::Integer)
   i=n+1
   # check if i is prime and if not increment by 1
   # once you find a prime, return it
 end
```
