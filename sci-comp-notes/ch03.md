Chapter 3: Data Types
=============

[Return to all notes](index.html)


Numeric Types
-------------

One of the first things that is important is a knowledge of how computers store numbers and other mathematical objects.  You should review details of integers and floating point numbers in your Introduction to Computer Science text or the following  wikipedia pages for further information:

* [wikipedia's page on integers](http://en.wikipedia.org/wiki/Integer_(computer_science\))
* [wikipedia's page on floating point numbers](http://en.wikipedia.org/wiki/Floating_point_numbers)


Julia's standard numbers and mathematical objects
----------------

Since we are primarily using Julia in this class, there are a few extensions of the standard types of mathematical numbers.  Specifically, rational numbers and complex numbers.  
Julia has built-in number and other mathematical data types including those listed above in various sizes as well as rational numbers, matrices, and complex numbers.  The following are links to the Julia documentation for

* [integers](http://docs.julialang.org/en/latest/manual/integers-and-floating-point-numbers/)
* [floating point](http://docs.julialang.org/en/latest/manual/integers-and-floating-point-numbers/)
* [rational numbers](http://docs.julialang.org/en/latest/manual/complex-and-rational-numbers/)
* [complex numbers](http://docs.julialang.org/en/latest/manual/complex-and-rational-numbers/)

Size of numbers
------------

Storing a single number on a computer takes certain amount of memory.  There are a lot of specifics in the links above or in your Computer Science text, but in short there are different types of integer and floating point numbers.  In Julia, there are 8, 16, 32, 64, 128 bit versions of integer (both signed and unsigned) and 16, 32 and 64 bit floating point numbers.  For example, to set the number 1 as a 16 bit signed integer, type
```
Int8(1)
```

and to determine the type of this (or anything), type `typeof(ans)` and it returns `Int8`.  If you just enter `x=5` and then `typeof(5)` you should get `Int64` (or maybe `Int32` if you're using a 32-bit machine )

If you type `typeof(3.0)` you will probably get `Float64`, but possibly `Float32`.  

BigInts and BigFloats
------

As we saw in the previous chapter, sometimes you'll run out of numbers (on the integer side) or precious when using a float.  This is where `BigInt`s and `BigFloats` come in handy.  A `BigInt` will grow as needed.  Here's an example.  If you find powers of 10 as in
```
[10^i for i=10:20]
```

one will see that up to $10^{18}$, you get a reasonable number and then what happens?   From 18 to 19 there's a overflow error, however Julia does not report it as such by default.  The following will report the overflow error and nearly does the same thing:
```
x=10^10
for i=1:20
    println(x)
    x=Base.checked_mul(x,10)
end
```

Now if we do the following using BigInts:

```
[big(10)^i for i=10:20]
```

then it gives what we expect.  

###BigFloats

Sometimes you may want more precision than a Float64 gives.  For example, what if you want to calculate $\pi$ to 100 digits.[^fn: And in fact, I calculated $\pi$ to about 100,000 digits for a talk in Spring 2016 using Julia]  Although I won't go through that, but we can generate a big float with value 1.0 using `x=big(1.0)` enter this in and you will get:
```
1.000000000000000000000000000000000000000000000000000000000000000000000000000000
```

and you can count the number of zeros or you can determine the precision using `precision(x)` and this returns 256, which is the number of bits and it has 4 times the precision of `Float64`, which generally has about 16 decimal digits of accuracy, so this would have about 64 decimal digits.  

You can get more precision using the `setprecision` function.  For example:
```
setprecision(2^10)
```
returns 1024 (or each number is stored in 128 bytes of memory).  Then typing `big(1.0)` returns:
```
1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

which has about 250 decimal digits of accuracy.  
