Chapter 10: Advanced Features of Functions
========

[Return to all notes](index.html)

This chapter covers a bit more on Functions...

We know how to define an argument with a type, but what if more information is needed for an argument. Recall our factorial function
```
function fact(n::Integer)
  if n==0
    return 1
  end
  n*fact(n-1)
end
```

but what happens if you put in a negative number?  Try it.

We can prevent it with the following:
```
function fact(n::Integer)
    n>=0 || throw(ArgumentError("The argument must be a nonnegative integer."))
  if n==0
    return 1
  end
  n*fact(n-1)
end
```

The first line of this evaluates `n>=0` if that is false, the second after the || is evaluated and an error is thrown.  

Optional arguments
------

Let's return to Newton's method, which we wrote before as

```
function newton(f::Function, df::Function,x0::Number)
    x1=x0
    x2=x0+1
    steps = 0
    while abs(x2-x1)>1e-6 && steps<100
        x1=x2
        x2=x1-f(x1)/df(x1)
        println(x2)
        steps += 1
    end
    x2
end
```

Notice that we hard-coded the stopping criteria and the max number of steps. Let's adapt this function to include the following:

1. Make the stopping condition and max steps as optional parameters.  
2. Check to make sure that they are valid.  
3. If the number of steps exceeds the maximum number of steps, then throw an `ErrorException` and a reasonable message.


First, we can define an argument to be option by assigning a default value.  Let's define the tolerance (`tol`) and the max number of step (`max_steps`) in the following way:

```
function newton(f::Function, df::Function,x0::Number,tol=1e-6,max_steps=100)
    x1=x0
    x2=x0+1
    steps = 0
    while abs(x2-x1)>tol && steps<max_steps
        x1=x2
        x2=x1-f(x1)/df(x1)
        println(x2)
        steps += 1
    end
    x2
end
```


Variable Number of arguments
-----

Recall that the geometric mean of a set of numbers \\(x_1,x_2, \ldots, x_n \\) is given by

\\[ \sqrt[n]{x_1x_2 \cdots x_n}\\]

It would be great to write a `geom_mean` function which computed the geometric mean for any number of elements.  
It would be unfortunate if we have to write different functions for different number of arguments.   We can write a variable number of arguments with a ... trailing the last argument.  The following is a generalized version of the geometric mean:

```
function geom_mean(x::Number...)
    prod(x)^(length(n))
end
```

and this allows the following:

```
geom_mean(1,2)
```

as well as
```
geom_mean(1,2,3,4)
```

See [The Julia documentation on Variable Arguments](http://docs.julialang.org/en/latest/manual/functions/#varargs-functions) for more information on variable arguments.  

Multiple Dispatch
------

Generally each function that you write (or is built-in to Julia) has a signature which is the number and types of arguments.  For example, the function `newton` above has three arguments.  The first two are functions, and the second is a number.

Julia allows functions of the same name with different signatures.  The execution of this is called *multiple dispatch*.   The classic example is the `+` function.  If we only consider those with 2 arguments, then + can take 2 integers an integer and a float, two complex, a float and a complex, etc.  Each one of those functions have the same name with different signatures.  

To view all of the methods, use the `methods` command.  For example, typing `methods(+)` lists 163 methods and the signature of each.  

Example of Multiple dispatch
-----

Let's consider a function called `the_max` which return the maximum number of a whole bunch of possible arguments.  Let's start going through them:

* 2 numbers

    ```
    function the_max(x::Number,y::Number)

    end
    ```

* 3 numbers
    ```
    function the_max(x::Number,y::Number,z::Number)

    end
    ```

* variable number of numbers
    ```
    function the_max(x::Number...)

    end
    ```

* a 1-D array of numbers
    ```
    function the_max(arr::Array{Number,1})

    end
    ```

* a UnitRange
    ```
    function the_max(r::FloatRange)

    end
    ```
* A FloatRange

    ```
    function the_max(r::FloatRange)

    end
    ```



After we put these all in, type `methods(the_max)` to see the 5 different signatures of the function.  

### Parametric Types

Let’s say that we wish to create a function that does basically the same thing for different types of arguments. For example, let’s return to the example in which you calculate the mean of a set of numbers.

It is probably of interest to return the same type as the input. For example, if you enter Float32’s then return Float32s. From what we’ve seen above, it would be logical to define a different method with a different argument signature for each. This, however, is a lot of work and unnecessary with what Julia calls Parametric Method.

Let's look at an example.  Consider the basic type of Polynomial.  

```
type Polynomial{T}
  coeffs::Vector{T}
end
```

This definition allows us to create a polynomial with coefficient of any type:

```
poly1=Polynomial([1,2,3])
```

And if the result is: `Polynomial{Int64}([1, 2, 3])`.  It would be nice if the result looked like a polynomial.  In this case, we can use the `show` command.  

```
function Base.show(stream::IO, p::Polynomial)
  str = ""
  for i = 1:length(p.coeffs)
      str = string(str,p.coeffs[i],"x^",i-1,i<length(p.coeffs)?"+":"")
  end
  show(stream, str)
end
```

and another nice thing that we'd like to do is an add command.  To do this, first, we need to import it as:
```
import Base.+
```

and then we can define adding two polynomials as:
```
function Base.+(p1::Polynomial,p2::Polynomial)
    Polynomial(p1.coeffs+p2.coeffs)
end
```

which will allow us to add two polynomials.  For example, if
```
poly2 = Polynomial([2,3,4])
```

then `print_poly(poly1+poly2)` returns:
```
3x^0+5x^1+7x^2
```

If we have a polynomial with floating point coefficients as
```
poly3=Polynomial([2.,3.,4.])
```

then `print_poly(poly1+poly3)` returns
```
3.0x^0+5.0x^1+7.0x^2
```

What if we have Strings as coefficients?

```
poly4 = Polynomial(["a","b","c"])
```

then
```
print_poly(poly4)
```

returns
```
ax^0+bx^1+cx^2
```
