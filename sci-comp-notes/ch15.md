Chapter 14: Parallel Computing
=====

[Return to all notes](../index.html)


Briefly, parallel computing is a method of running code on multiple processors (or multiple cores of the same processor) at the same time.  In general, this is a difficult task depending on where data is stored and retrieved.  The [Julia Documentation on parallel computing](http://docs.julialang.org/en/stable/manual/parallel-computing/) is a good place to start.

Let's start with something relatively simple. Consider the following code:
```
 function count_heads(n::Int)
    c::Int = 0
    for i=1:n
        c += rand(Bool)
    end
    c
end
```

which mimics flipping a coin `n` times.  We can simulate flipping 10 billion coins and finding the fraction that is heads by the following:

```
@time count_heads(10^10)/10^10
```

which returns
```
29.597828 seconds (6.25 k allocations: 263.473 KB)

0.5000025478
```

or about 30 seconds.  We now wish to run it simultaneously on 2 cores (which is what my machine has).  If we type
```
nprocs()
```

then julia returns the number of processors (cores) available to it.  Unless you did something special to start out julia, it will return 1.

### Adding additional cores

Type
```
addproc(1)
```

to add another core (if you know your machine has more (say 4), try `addproc(3)` for example).  


### Running parallel code.

First, we need to make sure that the function `count_heads` is available to each core of the machine.  To do this, we will start the function with the `@everywhere` macro:

```
@everywhere function count_heads(n::Int)
   c::Int = 0
   for i=1:n
       c += rand(Bool)
   end
   c
end
```

Any function that you will need on multiple cores will need to be prefaced with `@everywhere`.

We can now send code to different cores.  Type:

```
a= @spawn count_heads(5*10^9); b= @spawn count_heads(5*10^9); @time fetch(a)+fetch(b)
```

and you should get something similar to about half the time as above.

#### Exercise

1. Add two more cores to julia with the `addprocs` command.
2. Rerun the `@everywhere function count_heads` code above.
3. Create 4 spawning lines.  Call them `a, b, c` and `d` and use `2.5*10^9` for each.  
4. Time the sum of the four.  
5. Note: if you truly have 4 cores, then you will see a further halving of the time.  If not, you will probably only see the same results.  




### Parallel for loops

One issue with what we did above is that we have to think about spawning to individual processors or cores.  That is fairly annoying.  Fortunately, another helpful feature of julia is that of a parallel for loop.  Try the following code:

```
@time nheads = @parallel (+) for i=1:10^10
         Int(rand(Bool))
       end
```

and the time should be a fraction of the original head counter code where the fraction is the number of actual number of possible processors or cores

### Writing a parallel card simulator

If we have the following code to simulate a large number of hands:
```
function check_hand(trials::Int,f::Function)
    local deck=collect(1:52)
    local numhands=0
    for i=1:trials
        shuffle!(deck)
        h = Hand(map(Card,deck[1:5]))
        if(f(h))
            numhands+=1
        end
    end
    numhands
end
```

then we can put the following in to test a parallel version of the check_hand:  


```
function para_check_hand(N::Int,f::Function)
       local num1= @spawn check_hand(div(N,2),f)
       local num2= @spawn check_hand(div(N,2),f)
       fetch(num1)+fetch(num2)
end
```

and then we can time it:

```
@time para_check_hand(10^7,is_full_house)
```

and this returns:
```
7.577296 seconds (2.68 k allocations: 115.470 KB)
14268
```

to compare it,

```
@time check_hand(10^7,is_full_house)
```

returns
```
15.470629 seconds (160.00 M allocations: 8.643 GB, 5.79% gc time)
14708
```

or twice the time.

Alternatively, we can use a for loop to do a similar computation in parallel (on multiple cores):

```
@time numhands = @parallel (+) for i=1:10^3
       check_hand(10^4,is_full_house)
       end
```

which should return about the same result and took about 8.5 seconds.  
