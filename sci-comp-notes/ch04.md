Chapter 4: Loops and Branching
=============

Boolean values and  if statements
------
A boolean value is something that is either `true` or `false`.  These are built-in constants in Julia.  Sometimes we will want to know if a statement is true or false, but generally, we will use them in other structures.

We often use boolean to test various conditions.  For each, testing equality, or comparison of numbers we use `==,<,>,<=,>=`.

If we set `x=3` and then can just type `x==3`, `x<3`, `x>=3` to test a variety of comparisons.  

### Compounds boolean statements

We often want to test multiple boolean statements and can build up compound ones with either the "and" (`&&`) or "or" (`||`) operators.  If we have `x=3` and `y=10`, if we want to test that `x` is greater than 0 and `y` is 5, by
```
x>=0 && y==5
```





###if statements

An `if` statement is often used inside of a procedure to do different things depending on the value of a variable.  Consider the piecewise version of the absolute value.  Mathematically, we write:
$$ |x| = \begin{cases} x & x \geq 0 \newline
-x & x<0
\end{cases} $$

We can make a Maple procedure for the absolute value the following way:

```
absol := proc(x::numeric)::numeric;
  if x >= 0 then
     return x:
  else
     return -1*x:
  end if:
end proc:
```

And to help determine if it is correct, evaluate `absol(3)` and `absol(-7)`.  

###Exercise

The modulus of an integer is the remainder in division.  For example, 7 mod 3 is 1.  

Write a procedure call `isOdd` that take a positive integer (type `posint`) and returns `true` if the number is odd and `false` if not.  Use the modulus with the divisor 2.  


Loops
-----
A *loop* is a series of statements that are repeated either a fixed number of times or until a condition occurs.  They can be very helpful if a large number of operations need to be done in a predictable manner.  


###while loops

Another very common construction for programming is called a while loop.  Basically, we want to run a few statements while some boolean statement is true.  Here's a simple example:

```
n:=1:
while n<10 do
  print(n):
  n:=n+1:
end do:
```

And that isn&#8217;t very interesting, but we can reproduce the `seq` command crudely in the following way.  Let&#8217;s say we want to return a list of numbers from 1 to $n$, where $n$ is a positive integer.

```
intList := proc (n::posint)::list;
   local list := []:
   local i := 1:
   while i <= n do
     list := [op(list), i]:
     i := i+1:
   end do:
   return list:
end proc:
```

A few things to note about this:

* Putting `local` in front of a variable tells Maple the variables are local to the procedure.  That is, don't use the values outside the procedure if they exist.
* The line `list:=[op(list), i]` simply adds the value of `i` to the end of the list. Other languages have a `push` command to do this.  
* The `op` command in the line strips the brackets off of the list, returning a sequence.  

Let's run some examples:

* typing `intList(6)` returns `[1,2,3,4,5,6]`
* typing `intList(10)` returns `[1,2,3,4,5,6,7,8,9,10]`



The following is a more interesting example.  If you have a positive integer $n$, the following returns a list of all factors of $n$.  Recall that for a positive integer $n$, the factors of $n$ are all numbers that divide $n$ with 0 remainder.  Both 1 and $n$ are always factors of $n$.   

```
allfactors:=proc(num::posint)::posint;
  local factors := [1]:
  local n := 2:
  while n <= num do
    if num mod n = 0 then
      factors := [op(factors), n]:
    end if:
    n := n+1:
  end do:
  return factors:
end proc:
```
And here&#8217;s a couple of examples of this

* type `allfactors(6)` returns `[1,2,3,6]`
* type `allfactors(29)` returns `[1,29]`


Another possible procedure that you want is to determine if a number is prime.  Although this is built-in, let&#8217;s find a way to do this using the allfactors command.

```
isPrime := proc(n::posint)::boolean;
  local factors := allfactors(n);
  return evalb(factors[2] = n)
end proc:
```

Alternatively, prime numbers have only 2 numbers in factor list and so it can be checked if the length (using the `nops`, for number of operands, command) is 2.

```
isPrime := proc(n::posint)::boolean;
  return evalb(nops(allfactors(n))=2)
end proc:
```

where `evalb` will return true or false instead of (perhaps) the equation.  Note that this nests a number of commands that could be done as steps.

Another nice use of all factors is the use of a theorem that says that the total number of factors is even (factors pair up) unless the number is a perfect square. We will then use this and the `isOdd` function you wrote above to write an `isPerfectSquare` procedure.

```
isPerfectSquare := proc(n::nonnegint)::truefalse;
  if isOdd(nops(allfactors(n))) then
    return true
  else
    return false
  end if
end proc:
```

or to even shorten this more, we can write this as:

```
isPerfectSquare := proc(n::nonnegint)::truefalse;
  return isOdd(nops(allfactors(n)))
end proc:
```


#### Infinite Loops

It is common in a while loop to keep running it forever.  This occurs if you don't have some code that will stop it.  A couple of things:

* Make sure something is changing in your loop.  If you intend to stop the loop on an index, make sure the index is updating.  

* Look at your code and see if you have something that you think will stop the loop.  What ever is in the boolean statement needs to eventually switch.

* Stop the code if you need to.  Maple has a Stop Sign on the toolbar.  This will interrupt the kernel.  Often you will need to do this, but this may not actually give you control back.  You can also restart the kernel using the circle arrow on the toolbar.  

* If you can't figure out why it is in an infinite loop, put print statements inside to print out values of variables.  






### Compound booleans in an `if` statement or `while` loop

Recall that a boolean is something that evaluates to true or false and is needed in an `if` statement or `while` loop.  Often more than one boolean is needed.  This is called a compound boolean and is created with either an `and` or an `or`.

* An `or` compound statement.  If either or both are true, the result is true, otherwise false.  

   * true or true is true
   * true or false is true
   * false or true is true
   * false or false is false

* An `and` compound statement.  Both must be true to be true, otherwise false

   * true and true is true
   * true and false is false
   * false and true is false
   * false and false is false


Here's an example, where we just print out all odd perfect squares less than 100.  (Note: there is a better way to do this, but the point is to show how to use a compound statement)

```
n:=1:
while n<=100 do
  if isOdd(n) and isPerfectSquare(n) then
    print(n)
  end if:
  n:=n+1:
end do:
```


In addition, the `not` command switches a true to false and a false to true. A simple version of this would be if we had an `isOdd` function as written above, then the following would be an `isEven` function:

```
isEven:=proc(n::nonnegint)::truefalse;
  return not isOdd(n)
end proc:
```

### More functions with prime numbers

We want to find the smallest prime number bigger than a number n.  We will make a procedure that return the next prime.

```
theNextPrime := proc(n::integer)::integer;
  local k := n+1:
  while not(isPrime(k)) do
     k := k+1
  end do:
  return k:
end proc:
```

###Exercise

A perfect number is a positive integer $n$, that has the property that the sum of the factors (other than $n$ itself) equals $n$.  We will write a few procedures here to find perfect numbers.  





1. Write a procedure called `isPerfect` which takes a positive integer, $n$ and return either true or false on whether or not $n$ is a perfect number. (Hint: use the built-in function `add` which will take a list of numbers and return the sum.)

2. Test your procedure on some known perfect numbers (6 and 28) and others (like all other numbers less than 100 are not perfect.)

2. Write a procedure called `nextPerfect` which takes an integer, $n$ and return the next perfect number greater than $n$.  


4. Test your procedure to find the first few perfect numbers.  (Don't go too big or Maple will bog down.  )






### For loops

The following is a simple for loop that prints out the numbers 1 to 10
```
for i from 1 to 10 do
  print(i):
end do:
```

If you want to skip numbers or count backwards, the following
```
for i from 1 by 2 to 19 do
  print(i):
end do:
```

```
for i from 10 by -1 to 1 do
  print(i):
end do:
```

and the following adds numbers in a list.

```
s := 0;
for i in [3, 5, 7, 11, 13, 19] do
  s := s+i
end do
```

Note: there is a command called `add` that will also do the above.

```
add([3,5,7,11,13,19])
```

This isn&#8217;t a very interesting example, but shows the syntax of a for loop.  Often a for loop is used in conjunction with a procedure.   Above, we used a `while` loop to create an integer list.  However, it was a loop with a fixed number of steps in which a `for` loop is better to use.  Here's a different way to create the integer list:

```
intList := proc(n::posint)::list;
   local li := [];
   local i;
   for i to n do
     li := [op(li), i]
   end do;
   return li
end proc
```

Also, there are two variables that live inside the procedure: `i` and `li`.  Because they are not needed outside the procedure, we declare them **local**.  If you don't declare them as local, Maple will give a warning.    


If Maple didn&#8217;t have a factorial builtin, here&#8217;s a way we could handle it.

```
facty:=proc(n::nonnegint)::posint;
   local i,fact:=1:
   for i from 1 to n do
     fact:=fact*i:
   end do:
   return fact:
end proc:
```

and the heart of this is that the for loop multiplies all of the numbers from 1 to n together (it does this one step at a time).  

Note: if you call this function `factorial`, you will get a warning from Maple, which is why it is called `facty`.  




While Loops Versus For Loops
-----

No this, isn't a smackdown between these two.  A big question often is when should I use a `while` loop and when should I use a `for` loop.  The general rule of thumb is:

* If you know that you need to run code for a fixed number of times, use a for loop
* If you need to do something in a list and map doesn't work well, use a for loop.
* If you don't use a while loop.  Generally, the *doing* something in the loop will affect how many times the loop is run.  

Types
------

All of these procedures have the arguments and return typed.  That is, it is important to say what type of Maple object you can pass it.  Here's a list of many common types:

* **integer**: the standard mathematical integer
* **posint**: positive integer.  That is 1,2,3,...
* **negint**: negative integer. That is, -1, -2, -3, ....
* **nonnegint**: non negative integer,  0, 1, 2, 3 ...
* **nonposint**: non-positive integer: 0,-1,-2,-3,...
* **rational**: rational (fraction) number.
* **realcons**: a real constant
* **numeric**: a number (integer, real, rational)
* **truefalse**: a boolean (a true or false value)
* **list**: a list, like `[1,2,3]`
* **procedure**: a mathematical function.
* **range**: an interval, like `1..2` all numbers between 1 and 2.  



Recursion
-----

Above, we saw how to compute the factorial of a number using a for loop.  There&#8217;s another way to do this.  We can define the factorial in the following way:
$$ n!=\begin{cases}1&n=0\newline n\cdot(n-1)!&\text{otherwise}\end{cases}$$

The big difference is that inside the function is a call to the function.  This is what is called a recursive function.  Often this is very helpful and the factorial is a great example of this.  We can write the factorial this way in the following:

```
factr := proc(n::nonnegint)::posint;
   if n = 0 then
      return 1
   else
      return n*factr(n-1);
   end if
end proc:
```

or using the `ifelse` function:

```
factr := proc(n::nonnegint)::posint;
   return ifelse(n=0,1,n*factr(n-1));
end proc:
```

### Exercise

1. Try the function `factr` for various values of $n$.  
2. Compare the results to the built-in factorial !.  
