Chapter 2: Functions
=============

[Return to all notes](index.html)

In any language, the function is one of the most important ideas and this chapter is a review of functions with examples in julia.   [The Julia documentation on functions](http://docs.julialang.org/en/latest/manual/functions/) is a great place for details.

Simple example
-----

A simple example of a julia function is

```
function sq(x)
  x^2
end
```

which just returns the square of the argument, called x.  An alternative way to do this is the following:
```
f(x)=x^2
```

Check that both `sq` and `f` return what is expected.  

Return statement
----

In the function `sq` the returned value is the last line of the function.  If you want to return a value before the last line you can use the `return` command.  The following will return true if the number is odd and false if the number is true:

```
function isOdd(n)
  if mod(n,2)==1
    return true
  end
  false
end
```

The `mod` function is the remainder of n divided by 2.  If the remainder is 1, then the number is odd.  The function is returned from that line.

A better way to write this (but doesn't use the return statement) just evaluates if `mod(n,2)` is 1 or not:

```
function isOdd(n)
  mod(n,2)==1
end
```

Exercise
---

* Write a function that returns the mean (average of 3 numbers)



Multiple Return Values
-------------

A very nice feature of Julia functions is that of multiple return values.  Instead of only being able to return a single number (or requiring to send an array or object), you can return more than 1 number (or other data type). For example.

```
function h(x,y)
  x+y,x-y
end
```
and if you call this, say `h(3,5)` you will get the result `(8,-2)` or if you say
```
p,q=h(3,5)
```
the p will take on the value 8 and q will be equal to -2.  

Argument Types
------

Everything looks nice above except that you might call a function on a data type that doesn't make any sense.  For example, if you type `h(3,"hi")` then Julia will try to add and subtract these two values.  Resulting in an error.

Instead, we will specify the types of the arguments in `h` by the following:
```
function h(x::Number,y::Number)
  x+y,x-y
end
```

Note: you should restart the kernel before evaluating this.  You will then notice that `h(3,5)` still works and `h(3,"hi")` does not, but the error is a little clearer.  

Exercise
-----

* redo the `isOdd` function from above using a type for the argument.  Look at [the Julia docs on types](http://docs.julialang.org/en/latest/manual/types/) for more information on what types there are.  


Factorial Function
-----

Mathematically, we define the factorial as a function on a non-negative integer as
\\[ n! = n(n-1)(n-2)\cdots 3 \cdot 2 \cdot 1 \\]

or the product of all of the numbers from itself down to 1.  There are a number of ways to program this function as we will see.  The following is a way using a `for` loop

```
function fact(n::Integer)
    prod=1
    for i=1:n
        prod *= i
    end
    prod
end
```

We store the result (product) in a variable called prod and multiply all of the numbers up to `n`.  

Exercise
----

* Test the function above for various positive integers.
* What happens if you put in 0 or a negative integer?
* What happens if you put in a number that is not an integer?

Recursive Functions
------

Another type of function is one that calls itself and is called a *recursive function*.  One of the standard examples of this is the factorial function.   


Above, we saw how to compute the factorial of a number using a for loop.  There&#8217;s another way to do this.  We can define the factorial in the following way:
$$ n!=\begin{cases}1&n=0\newline n\cdot(n-1)!&\text{otherwise}\end{cases}$$

The big difference is that inside the function is a call to the function.  This is what is called a recursive function.  Often this is very helpful and the factorial is a great example of this.  We can write the factorial this way in the following:

```
factr := proc (n::integer)::posint;
   if n = 0 then
      return 1
   else
      return n*factr(n-1);
   end if
end proc:
```

Here&#8217;s another fun example.  A number $n$ is called *happy* by the following
1. Take the digits of $n$ and square each one.
2. Sum the squares.  
3. if the sum is 1, then the number is happy, if not repeat these steps.

Note: it&#8217;s also helpful that if this process results in the number 4, then you can never result in a sequence that reaches 1.  You can call these number *unhappy*.  

For example, 13 is a happy number because $1^2+3^2=10$ and $1^2+0^2=1$, so the result ends in 1. The number 19 is also happy because $1^2+9^2=1+81=82$, then $8^2+2^2=64+4=68$, then $6^2+8^2=36+64=100$, then $1^2+0^2+0^2=1$.  

The number $4$ isn&#8217;t happy because $4^2=16$, then $1^2+6^2=1+36=37$, then $3^2+7^2=9+49=58$, then $5^2+8^2=25+64=89$, then $8^2+9^2=64+81=145$, then $1^2+4^2+5^2=1+16+25=42$, then $4^2+2^2=16+4=20$, then $2^2+0^2=4$ and since we have returned to 4, this will continue cycling, so we stop and say 4 is unhappy.  (It has been proven that any unhappy number will eventually hit this cycle.)

To write this in Maple, first, it is helpful to have a procedure that splits any positive integer into its digits.  Here&#1827;s such a procedure:

```
splitDigits := proc (n::posint)::boolean;
   local list := [], k := n;
   while 9 < k do
      list := [k mod 10, op(list)];
      k := iquo(k, 10)
   end do;
   return [k, op(list)]
end proc:
```

and test this a bit using some 3 and 4 digits numbers.

Then we can write a `isHappy` procedure in the following way.

```
isHappy := proc (n::posint)::boolean;
  if n = 1 then return true end if;
  if n = 4 then return false end if;
  return isHappy(add(k -> k^2, splitDigits(n))))
end proc:
```

Find the numbers less than 100 that are happy.  


###Exercise

A fibonacci number is defined as $F(1)=1, F(2)=1$, then $F(n)=F(n-1)+F(n-2)$ for $n \geq 3$.  This is naturally a recursive function.  Write a procedure $F$ that take a positive integer $n$ and returns the $n$th Fibonacci number using recursion.  Find the first 20 Fibonacci number (hint: use the `map` command)
