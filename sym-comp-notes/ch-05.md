Advanced Computing Techniques in a Computer Algebra System
==================

The following are number of advanced techniques in Maple.  Again, these are general ideas that appear in any CAS, but the format will be specific to Maple.  These allow a user of Maple to create more complicated series of mathematical steps in a nice way. The following techniques are described here:

* *procedures*  These are similar to functions that we saw earlier, but allow more complicated steps to occur. 
* *boolean values*  A boolean is something that is either true or false.  
* *if and while statements*  An if statement allows a few statements of code to branch depending on some condition.  A while statement allows for a few statements of code to continue to run until a condition occurs. 
* *loops*  A loop is a few statements of code that is run generally a fixed number of times. 
* *recursion*  Recursion is a type of procedure that allows code to call itself.  Although often you can generate code that duplicates recursive code, it is often clearer to understand and often come directly from mathematical statements. 
* *libraries*  We have used libraries in this class and here we will create a small one. 

Procedures
-------

A procedure is very similar to a function in any computer language.  In Maple, these are similar in that there is a input (or a number of inputs) and the result is some output (numbers, a plot, an expression).  In fact, all commands in Maple are just procedures. 

Recall that if we have a simple function that returns the square of a number, we can write that as
```
f:=x->x^2
```

We can also define a procedure in a similar manner. 
```
F:=proc(x::numeric)::numeric;
return x^2:
end proc:
```

A few things to note with this

* This is much more complex to write out than the equivalent function.  
* A procedure allow more complicated structures as we will see. 
* You can call this in the same way, $F(2),F(-2)$ for example. 
* The types of input is defined for us (these are options).  We can only use this to square numbers (integers, decimals, etc.)
* You will notice an error if you do $F(x+1)$.  

We can use this procedure to square numbers, but not expressions.  

Let's also examine a similar procedure that adds numbers:
``` 
add:=proc(x::numeric,y::numeric)::numeric;
return x+y:
end proc:
```

###Exercises

1. remove the semicolon and colon off the end of the lines of the procedure, reenter it and see what happens.  Can you understand what is going on?
2. Write a procedure called `mult` that multiplies two numbers and returns the product. 
3. Write a procedure called `average` that returns the average of three numbers. 

Boolean values and  if statments
------
A boolean value is something that is either `true` or `false`.  These are built-in constants in Maple.  Sometimes we will want to know if a statement is true or false, but generally, we will use them in other structures.  

###if statements

An `if` statement is often used inside of a procedure to do different things depending on the value of a variable.  Consider the piecewise version of the absolute value.  Mathematically, we write:
$$ |x| = \begin{cases} x & x \geq 0 \newline 
-x & x<0 
\end{cases} $$

We can make a Maple procedure for the absolute value the following way:

```
absol := proc(x::numeric)::numeric;
  if x >= 0 then
     return x:
  else
     return -1*x:
  end if:
end proc:
```

And to help determine if it is correct, if we plot the function, we get the following:

which is what we would expect.  

###Exercise

Write a procedure called `difforint` that takes an expression of x (don't give it a parameter type) and an integer.  It returns the derivative if the second parameter is positive or the integral.   Test it on a number of expressions.  


###while loops

Another very common construction for programming is called a while loop.  Basically, we want to run a few statements while some boolean statement is true.  Here's a practical example:

We want to find the smallest prime number bigger than a number n.  We will make a procedure that return the next prime.  We will use the built-in function `isPrime`.  

```
nextPrime := proc(n::integer)::integer
  local k := n+1: 
  while not(isPrime(k)) do
     k := k+1
  end do:
end proc:
```

Note: there is already a function that does this, but this gives an interesting example.

###Another Example 

This shows how to determine if a number is prime.  (Note: this is not an efficient way, mainly because it checks if n is divisible by any integer, when it is only necessary to check primes.  

```
isPrime :=proc(n::integer)::boolean
   local k :=2
   while k < sqrt(n) do
     if n mod k = 0 then
        return false:
     end if
     k := k + 1
  end do
end proc:
```

###Exercise

First, to find all of the factors of a number $n$ (with their multiplicities) we will use `ifactors`.  (Check out the help).  Here's some examples:

*
* 
*


It will also be helpful to have a list with all of the factors.  This can be done with the following function:
```
allfactors := n -> map(x->[seq(x[1],n=1..x[2])],ifactors(n))
```

A perfect number is a number $n$ in which the sum of all of its factors equals $n$.  Write a procedure called `nextPerfect` which takes an integer, $n$ and return the next perfect number greater than $n$.  







Loops
-----
A *loop* is a series of statements that are repeated either a fixed number of times or until a condition occurs.  They can be very helpful if a large number of operations need to be done in a predictable manner.  

###For loops

The following is a simple for loop that prints out the numbers 1 to 10
```
for i from 1 to 10 do
  print(i):
end do:
```

This isn't a very interesting example, but shows the syntax of a for loop.  

Often a for loop is used in conjunction with a procedure.  If Maple didn't have a factorial builtin, here's a way we could handle it. 

```
facty:=proc(n::integer)::integer;
   local i,fact:=1:
   for i from 1 to n do
     fact:=fact*i:
   end do:
   return fact:
end proc:
```

and the heart of this is that the for loop multiplies all of the numbers from 1 to n together (it does this one step at a time).  

Note: if you call this function `factorial`, you will get a warning from Maple, which is why it is called `facty`.  

Also, there are two variables that live inside the procedure: i and fact.  Because they are not needed outside the procedure, we declare them **local**.  

Recursion
-----

Creating a Library
-----


Troubleshooting
-------