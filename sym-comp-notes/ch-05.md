Advanced Computing Techniques in a Computer Algebra System
==================

The following are number of advanced techniques in Maple.  Again, these are general ideas that appear in any CAS, but the format will be specific to Maple.  These allow a user of Maple to create more complicated series of mathematical steps in a nice way. The following techniques are described here:

* *procedures*  These are similar to functions that we saw earlier, but allow more complicated steps to occur. 
* *boolean values*  A boolean is something that is either true or false.  
* *if and while statements*  An if statement allows a few statements of code to branch depending on some condition.  A while statement allows for a few statements of code to continue to run until a condition occurs. 
* *loops*  A loop is a few statements of code that is run generally a fixed number of times. 
* *recursion*  Recursion is a type of procedure that allows code to call itself.  Although often you can generate code that duplicates recursive code, it is often clearer to understand and often come directly from mathematical statements. 
* *libraries*  We have used libraries in this class and here we will create a small one. 

Procedures
-------

A procedure is very similar to a function in any computer language.  In Maple, these are similar in that there is a input (or a number of inputs) and the result is some output (numbers, a plot, an expression).  In fact, all commands in Maple are just procedures. 

Recall that if we have a simple function that returns the square of a number, we can write that as
```
f:=x->x^2
```

We can also define a procedure in a similar manner. 
```
F:=proc(x::numeric)::numeric;
return x^2:
end proc:
```

A few things to note with this

* This is much more complex to write out than the equivalent function. 
* To get a line inside a procedure without evaluating it, type SHIFT-ENTER
* A procedure allow more complicated structures as we will see. 
* You can call this in the same way, $F(2),F(-2)$ for example. 
* The types of input is defined for us (these are options).  We can only use this to square numbers (integers, decimals, etc.)
* You will notice an error if you do $F(x+1)$.  

We can use this procedure to square numbers, but not expressions.  

Let's also examine a similar procedure that adds numbers:
``` 
add:=proc(x::numeric,y::numeric)::numeric;
return x+y:
end proc:
```

###Exercises

1. remove the semicolon and colon off the end of the lines of the procedure, reenter it and see what happens.  Can you understand what is going on?
2. Write a procedure called `mult` that multiplies two numbers and returns the product. 
3. Write a procedure called `average` that returns the average of three numbers. 

Boolean values and  if statments
------
A boolean value is something that is either `true` or `false`.  These are built-in constants in Maple.  Sometimes we will want to know if a statement is true or false, but generally, we will use them in other structures.  

###if statements

An `if` statement is often used inside of a procedure to do different things depending on the value of a variable.  Consider the piecewise version of the absolute value.  Mathematically, we write:
$$ |x| = \begin{cases} x & x \geq 0 \newline 
-x & x<0 
\end{cases} $$

We can make a Maple procedure for the absolute value the following way:

```
absol := proc(x::numeric)::numeric;
  if x >= 0 then
     return x:
  else
     return -1*x:
  end if:
end proc:
```

And to help determine if it is correct, evaluate `absol(3)` and `absol(-7)`.  

###Exercise

Write a procedure called `difforint` that takes an expression of x (don't give it a parameter or return type) and an integer.  It returns the derivative if the second parameter is positive or the integral.   Test it on a number of expressions.  


###while loops

Another very common construction for programming is called a while loop.  Basically, we want to run a few statements while some boolean statement is true.  Here's a simple example:

```
n:=1
while n<10 do
  print(n):
  n:=n+1:
end do:
```

And that isn't very interesting, but we can reproduce the `seq` command crudely in the following way.  Let's say we want to return a list of numbers from 1 to $n$, where $n$ is a positive integer. 

```
intList := proc (n::posint)::list;
   local list, i; 
   list := []; 
   i := 1; 
   while i <= n do 
     list := [op(list), i]; 
     i := i+1:
   end do 
   return list: 
end proc
```

Some examples:

* typing `intList(6)` returns `[1,2,3,4,5,6]`
* typing `intList(10)` returns `[1,2,3,4,5,6,7,8,9,10]`



The following is a more interesting example.  If you have a positive integer $n$, the follow returns a list of all factors of $n$.  Recall that for a positive integer $n$, the factors of $n$ are all numbers that divide $n$ evenly.  Both 1 and $n$ are always factors of $n$.   

```
allfactors:=proc(num::posint)::posint;
  local factors, n; 
  factors := [1]; 
  n := 2; 
  while n <= num do 
    if num mod n = 0 then 
      factors := [op(factors), n] 
    end if: 
    n := n+1: 
  end do; 
  return factors 
end proc
```
And here's a couple of examples of this

* type `allfactors(6)` returns `[1,2,3,6]`
* type `allfactors(29)` returns '[1,29]`


Another possible procedure that you want is to determine if a number is prime.  Although this is built-in, let's find a way to do this using the allfactors command. 

```
isThisPrime := proc (n::posint)::boolean; 
  local factors := allfactors(n); 
  return evalb(factors[2] = n) 
end proc:
```

We want to find the smallest prime number bigger than a number n.  We will make a procedure that return the next prime.  We will use the built-in function `isPrime`.  

```
theNextPrime := proc(n::integer)::integer
  local k := n+1: 
  while not(isThisPrime(k)) do
     k := k+1
  end do:
end proc:
```


###Exercise

A perfect number is a positive integer $n$, that has the property that the sum of the factors (other than $n$ itself) equals $n$.  We will write a few procedures here to find perfect numbers.  





1. Write a procedure called `isPerfect` which takes a positive integer, $n$ and return either true or false on whether or not $n$ is a perfect number.

2. Write a procedure called `nextPerfect` which takes an integer, $n$ and return the next perfect number greater than $n$.  







Loops
-----
A *loop* is a series of statements that are repeated either a fixed number of times or until a condition occurs.  They can be very helpful if a large number of operations need to be done in a predictable manner.  

###For loops

The following is a simple for loop that prints out the numbers 1 to 10
```
for i from 1 to 10 do
  print(i):
end do:
```

This isn't a very interesting example, but shows the syntax of a for loop.  

Often a for loop is used in conjunction with a procedure.  If Maple didn't have a factorial builtin, here's a way we could handle it. 

```
facty:=proc(n::integer)::integer;
   local i,fact:=1:
   for i from 1 to n do
     fact:=fact*i:
   end do:
   return fact:
end proc:
```

and the heart of this is that the for loop multiplies all of the numbers from 1 to n together (it does this one step at a time).  

Note: if you call this function `factorial`, you will get a warning from Maple, which is why it is called `facty`.  

Also, there are two variables that live inside the procedure: i and fact.  Because they are not needed outside the procedure, we declare them **local**.  

Recursion
-----

Creating a Library
-----


Troubleshooting
-------